#include "X86.h"
#include "X86InstrInfo.h"
#include "X86Declassify.h"
#include "X86LLSCT.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Constants.h"
#include "../lib/IR/ConstantsContext.h"
#include "llvm/IR/IntrinsicInst.h"
#include "llvm/CodeGen/MachineJumpTableInfo.h"
#include "llvm/Support/WithColor.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/LivePhysRegs.h"
#include "X86Subtarget.h"
#include <set>
#include <queue>
#include <bitset>
#include "X86LLSCTUtil.h"
#include "llvm/TPE.h"

using namespace tpe;

namespace llvm::X86 {

namespace {
class Node;
}

// PTEX-TODO: Rename.
std::map<MachineInstr *, Node> runTaintAnalysis(MachineFunction& MF);

}

namespace tpe {

using namespace llvm::X86;
  
namespace llvm::X86 {
namespace {
template <class Range>

Register PrivacyMask::canonicalizeRegister(Register Reg) {
  if (Reg == X86::EFLAGS)
    return Reg;
  if (Register Reg64 = getX86SubSuperRegisterOrZero(Reg, 64))
    return Reg64;
  return Reg;
}

bool PrivacyMask::registerIsAlwaysPublic(Register Reg) {
  return Reg == X86::NoRegister || Reg == X86::RSP || Reg == X86::RIP;
}

void PrivacyMask::addPubReg(Register Reg) {
  Reg = canonicalizeRegister(Reg);
  if (!registerIsAlwaysPublic(Reg))
    PubRegs.set(Reg);
}

void PrivacyMask::delPubReg(Register Reg) {
  Reg = canonicalizeRegister(Reg);
  PubRegs.reset(Reg);
}

bool PrivacyMask::hasPubReg(Register Reg) const {
  Reg = canonicalizeRegister(Reg);
  if (registerIsAlwaysPublic(Reg))
    return true;
  return PubRegs.test(Reg);
}

void PrivacyMask::print(llvm::raw_ostream& os, const llvm::TargetRegisterInfo *TRI) const {
  os << "{";
  for (unsigned Reg = 0; Reg < NUM_TARGET_REGS; ++Reg) {
    if (PubRegs[Reg]) {
      os << TRI->getRegAsmName(Reg) << " ";
    }
  }
  os << "}";
}

bool pointeeHasPublicType(const llvm::Value *Ptr, std::set<const llvm::Value *>& seen) {
  assert(Ptr->getType()->isPointerTy() && "Require pointer value");
  if (!seen.insert(Ptr).second)
    return false;
  const auto rec = [&seen] (const llvm::Value *V) {
    return pointeeHasPublicType(V, seen);
  };
  Type *Ty;
  if (const AllocaInst *AI = dyn_cast<AllocaInst>(Ptr)) {
    Ty = AI->getAllocatedType();
  } else if (const GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(Ptr)) {
    Ty = GEP->getResultElementType();
  } else if (const GlobalValue *GV = dyn_cast<GlobalValue>(Ptr)) {
    Ty = GV->getValueType();
  } else if (const PHINode *Phi = dyn_cast<PHINode>(Ptr)) {
    // Check if any of the incoming values have public pointee type.
    return llvm::any_of(Phi->incoming_values(), rec);
  } else if (const GetElementPtrConstantExpr *GEP = dyn_cast<GetElementPtrConstantExpr>(Ptr)) {
    Ty = GEP->getResultElementType();
  } else if (const SelectInst *Select = dyn_cast<SelectInst>(Ptr)) {
    return rec(Select->getTrueValue()) || rec(Select->getFalseValue());
  } else if (isa<IntToPtrInst, LoadInst, Argument, CallBase, UndefValue, CastConstantExpr, ExtractValueInst, ExtractElementInst>(Ptr)) {
    // TODO: Can be more intelligent with load instructions if using alias analysis.
    return false;
  } else if (isa<ConstantPointerNull>(Ptr)) {
    return true;
  } else if (const FreezeInst *Freeze = dyn_cast<FreezeInst>(Ptr)) {
    return rec(Freeze->getOperand(0));
  } else {
    // Ptr->dump();
    report_fatal_error("Unhandled pointer");
  }
  return Ty->isPointerTy();
}

bool pointeeHasPublicType(const llvm::Value *Ptr) {
  std::set<const llvm::Value *> seen;
  return pointeeHasPublicType(Ptr, seen);
}

bool pointeeHasPublicType(const MachineMemOperand *MMO, const MachineFrameInfo *MFI) {
  if (MMO->getMemoryType().isPointer()) {
    return true;
  } else if (const llvm::Value *Val = MMO->getValue()) {
    if (const GlobalVariable *GV = dyn_cast<GlobalVariable>(Val))
      if (GV->isConstant())
        return false;
    return pointeeHasPublicType(Val);
  } else if (const PseudoSourceValue *PSV = MMO->getPseudoValue()) {
    return false;
  } else {
    return false;
  }
}

void PrivacyMask::removeClobberedRegisters(const MachineInstr& MI) {
  if (MI.isCall()) {
    // Remove all registers not in regmask.
    const auto regmask = util::get_call_regmask(MI);
    PubRegs &= ~regmask;
  }
      
  for (const MachineOperand& MO : MI.operands()) {
    if (MO.isReg()) {
      if (MO.isKill() || MO.isDef() || MO.isUndef())
        PubRegs.reset(canonicalizeRegister(MO.getReg()));
    } else if (MO.isRegMask()) {
      PubRegs &= util::regmask_to_bitset(MO.getRegMask());
    }
  }
}

bool PrivacyMask::allInputsPublic(const MachineInstr& MI) const {
  // TODO: IS it okay that memory accesses may come here?

  // If all register operands are undef, then assume we have XOR eax, eax primitive.
  if (llvm::all_of(MI.operands(), [] (const MachineOperand& MO) -> bool {
    if (MO.isReg() && MO.isUse()) {
      return MO.isUndef();
    } else {
      return true;
    }
  })) {
    return true;
  }
      
  for (const MachineOperand& MO : MI.operands())
    if (MO.isReg() && MO.isUse() && !hasPubReg(MO.getReg()))
      return false;
  return true;
}

bool PrivacyMask::anyOutputPublic(const MachineInstr& MI) const {
  for (const MachineOperand& MO : MI.operands())
    if (MO.isReg() && MO.isDef() && hasPubReg(MO.getReg()))
      return true;
  return false;
}
    
void PrivacyMask::transferForward(const MachineInstr& MI) {
  // FIXME: Should handle memory accesses specially, rather than just saying !MI.mayLoad().
  const bool all_inputs_public = !MI.mayLoad() && !MI.isCall() && allInputsPublic(MI);
  removeClobberedRegisters(MI);
  if (all_inputs_public)
    for (const MachineOperand& MO : MI.operands())
      if (MO.isReg() && MO.isDef())
        addPubReg(MO.getReg());

  // If the instruction is the end of the block, then remove any dead registers.
#if 0
  if (!MI.getNextNode()) {
    const MachineBasicBlock& MBB = *MI.getParent();
    std::set<MCRegister> live_regs;
    llvm::transform(MBB.liveouts(), std::inserter(live_regs, live_regs.end()),
                    [] (const auto& live_pair) -> MCRegister {
                      return canonicalizeRegister(live_pair.PhysReg);
                    });
    for (unsigned pub_reg = 0; pub_reg < PubRegs.size(); ++pub_reg)
      if (PubRegs[pub_reg] && live_regs.find(pub_reg) == live_regs.end())
        PubRegs.reset(pub_reg);
  }
#endif
}

static bool isPush(const MachineInstr& MI) {
  switch (MI.getOpcode()) {
  case X86::PUSH64r:
  case X86::PUSH64i32:
  case X86::PUSH64i8:
  case X86::PUSH64rmm:
    return true;
  case X86::ADJCALLSTACKDOWN64:
  case X86::ADJCALLSTACKUP64:
    return false;
  default: break;
  }

  if (MI.isCall() || MI.isReturn())
    return false;

  if (!MI.mayStore())
    return false;

  if (llvm::none_of(MI.operands(), [] (const MachineOperand& MO) {
    return MO.isReg() && MO.isUse() && MO.isImplicit() && MO.getReg() == X86::RSP;
  }))
    return false;

  if (llvm::none_of(MI.operands(), [] (const MachineOperand& MO) {
    return MO.isReg() && MO.isDef() && MO.isImplicit() && MO.getReg() == X86::RSP;
  }))
    return false;

  errs() << "isPush: unhandled instruction: " << MI;
  abort();
}

void PrivacyMask::transferBackward(const MachineInstr& MI) {
  bool any_output_public = !MI.isCall() && !isPush(MI) && anyOutputPublic(MI);
  size_t num_private_ins = 0;
  removeClobberedRegisters(MI);
  if (allowDeclassify()) {
    // Also check that all but one input is public, i.e., at most one input is private.
    num_private_ins = llvm::count_if(MI.operands(), [&] (const MachineOperand& MO) -> bool {
      return MO.isReg() && MO.isUse() && !hasPubReg(MO.getReg());
    });
    if (num_private_ins > 1)
      any_output_public = false;
  }
  if (any_output_public)
    for (const MachineOperand& MO : MI.operands())
      if (MO.isReg() && MO.isUse() && !MO.isUndef())
        addPubReg(MO.getReg());
}

bool PrivacyMask::setAllInstrInputsPublic(const MachineInstr& MI) {
  const auto orig_size = PubRegs.count();
  for (const MachineOperand& MO : MI.operands())
    if (MO.isReg() && MO.isUse())
      addPubReg(MO.getReg());
  return orig_size != PubRegs.count();
}

void PrivacyMask::meetForward(const Value& o) {
  // set intersection
  PubRegs &= o.PubRegs;
}

void PrivacyMask::meetBackward(const Value& o) {
  (void) set_union(o);
}

bool PrivacyMask::set_union(const Value& o) {
  const auto orig_size = PubRegs.count();
  PubRegs |= o.PubRegs;
  return PubRegs.count() != orig_size;
}

llvm::SmallVector<Register> PrivacyMask::getDeclassifiedRegisters(const PrivacyMask& pre, const PrivacyMask& post) {
  const auto PrivToPub = ~pre.PubRegs & post.PubRegs;
  if (!PrivToPub.any())
    return {};
  llvm::SmallVector<Register> Regs;
  for (unsigned i = 0; i < PrivToPub.size(); ++i)
    if (PrivToPub[i])
      Regs.push_back(static_cast<Register>(i));
  return Regs;
}

// PTEX-TODO: Move this }.
}

template <typename Func>
void getNonemptySuccessors(MachineBasicBlock& MBB, llvm::SmallVectorImpl<MachineBasicBlock *>& out, Func get_successors, bool inclusive) {
  std::set<MachineBasicBlock *> seen;
  std::queue<MachineBasicBlock *> todo;

  const auto add_succs = [&] (MachineBasicBlock *MBB) {
    for (auto *succ : get_successors(MBB))
      todo.push(succ);
  };

  // Add successors of starting block to queue.
  if (inclusive) {
    todo.push(&MBB);
  } else {
    assert(!MBB.empty());
    add_succs(&MBB);
  }
    
  while (!todo.empty()) {
    MachineBasicBlock *cur = todo.front();
    todo.pop();

    // If we have already processed this block, then ignore -- we are in a loop.
    if (!seen.insert(cur).second)
      continue;

    // If the block is non-empty, then we are done.
    if (!cur->empty()) {
      out.push_back(cur);
      continue;
    }

    // Otherwise, we need to add its successors as well.
    add_succs(cur);
  }
}

static llvm::SmallVector<MachineBasicBlock *> getNonemptySuccessors(MachineBasicBlock& MBB) {
  llvm::SmallVector<MachineBasicBlock *> succs;
  getNonemptySuccessors(MBB, succs, [] (MachineBasicBlock *MBB) { return MBB->successors(); }, false);
  return succs;
}

// PTEX-TODO: Relocate?
llvm::SmallVector<MachineBasicBlock *> getNonemptyPredecessors(MachineBasicBlock& MBB) {
  llvm::SmallVector<MachineBasicBlock *> preds;
  getNonemptySuccessors(MBB, preds, [] (MachineBasicBlock *MBB) { return MBB->predecessors(); }, false);
  return preds;
}

// PTEX-TODO: Need to add asserts for jump tables!!!!! Indirect jump table jumps should contain nonzero successors.
std::map<MachineInstr *, Node> runConstantTimePrivacyAnalysis(MachineFunction& MF) {
  assert(PrivacyPolicyOpt == ct || PrivacyPolicyOpt == ctdecl);
    
  const Function& F = MF.getFunction();
    
  std::set<MachineMemOperand *> Declassified;

  std::map<MachineInstr *, Node> Map, Bak;

  // All sensitive operands of transmitters are assumed to be public.
  // For now, we will just consider (a) the address operands of memory accesses,
  // (b) the operands of control-flow instructions, and (c) the operands of
  // division instructions to be sensitive.
  for (MachineBasicBlock& MBB : MF) {
    for (MachineInstr& MI : MBB) {
      auto& Val = Map[&MI];

      // Declassify operands of control-flow instructions
      if (MI.isCall()) {
        const MachineOperand& MO = MI.getOperand(0);
        if (MO.isReg()) {
          assert(MO.isUse());
          Val.pre.addPubReg(MO.getReg());
        }
      } else if (MI.isBranch()) {
        for (MachineOperand& MO : MI.operands())
          if (MO.isReg() && MO.isUse())
            Val.pre.addPubReg(MO.getReg());
      }

      // Declassify operands of division instructions
      switch (MI.getOpcode()) {
      case X86::DIV64r:
      case X86::DIV64m:
      case X86::DIV32r:
      case X86::DIV32m:
      case X86::IDIV64r:
      case X86::IDIV64m:
      case X86::IDIV32r:
      case X86::IDIV32m:
        for (MachineOperand& MO : MI.operands())
          if (MO.isReg() && MO.isUse())
            Val.pre.addPubReg(MO.getReg());
        break;
      }

      // Declassify address operands
      int MemIdx = getMemRefBeginIdx(MI);
      if (MI.mayLoadOrStore() && MemIdx >= 0) {
        assert(MI.getOpcode() != X86::LEA64r);
        const MachineOperand& BaseOp = MI.getOperand(MemIdx + X86::AddrBaseReg);
        const MachineOperand& IndexOp = MI.getOperand(MemIdx + X86::AddrIndexReg);
        if (BaseOp.isReg())
          Val.pre.addPubReg(BaseOp.getReg());
        if (IndexOp.isReg())
          Val.pre.addPubReg(IndexOp.getReg());
      }
    }
  }

  for (MachineBasicBlock &MBB : MF) {
    for (MachineInstr &MI : MBB) {
      auto &Val = Map[&MI];

      // If a memory access accesses a pointer value, then declassify *all* operands.
      for (MachineMemOperand *MMO : MI.memoperands()) {
        if (!pointeeHasPublicType(MMO, &MF.getFrameInfo()))
          continue;
        for (const MachineOperand &MO : MI.operands()) {
          if (!MO.isReg())
            continue;
          if (MO.isUse())
            Val.pre.addPubReg(MO.getReg());
          if (MO.isDef() && !MI.isCall())
            Val.post.addPubReg(MO.getReg());
        }
      }
    }
  }

  // Handle loads from constant memory.
  for (MachineBasicBlock &MBB : MF) {
    for (MachineInstr &MI : MBB) {
      if (!MI.mayLoad())
        continue;

      const bool loads_constant_mem = llvm::all_of(MI.memoperands(), [&] (const MachineMemOperand *MMO) -> bool {
        if (const llvm::Value *V = MMO->getValue()) {
          const GlobalVariable *GV = dyn_cast<GlobalVariable>(V);
          return GV && GV->isConstant();
        } else if (const PseudoSourceValue *PSV = MMO->getPseudoValue()) {
          return PSV->isConstant(&MF.getFrameInfo());
        } else {
          return false;
        }          
      });
      if (!loads_constant_mem)
        continue;
        
      const int MemBegin = getMemRefBeginIdx(MI);
      const int MemEnd = MemBegin + X86::AddrNumOperands;

      // Only continue if there are no non-memory-operand uses.
      bool has_non_mem_uses = false;
      for (int i = 0; i < MI.getNumOperands(); ++i) {
        if (MemBegin <= i && i < MemEnd)
          continue;
        const MachineOperand &MO = MI.getOperand(i);
        if (MO.isReg() && MO.isUse())
          has_non_mem_uses = true;
      }
      if (has_non_mem_uses)
        continue;

      // Finally, mark all def'ed registers as public.
      auto &Val = Map[&MI];
      for (const MachineOperand &MO : MI.defs())
        if (MO.isReg() && MO.isDef())
          Val.post.addPubReg(MO.getReg());
    }
  }


  bool changed;
  do {
    changed = false;

    // Transfer function for each machine instruction
    for (MachineBasicBlock& MBB : MF) {
      for (MachineInstr& MI : MBB) {
        auto& Node = Map[&MI];
        {
          Value Fwd = Node.pre;
          Fwd.transferForward(MI);
          changed |= Node.post.set_union(Fwd);
        }
        {
          Value Bwd = Node.post;
          Bwd.transferBackward(MI);
          changed |= Node.pre.set_union(Bwd);
        }
      }
    }

    // Meet (forward and backward)
    for (MachineBasicBlock& MBB : MF) {
      if (MBB.empty())
        continue;
	
      // Meet forward
      std::optional<Value> Fwd;

      // PTEX-TODO: Allow empty predecessors.
      for (MachineBasicBlock *PredMBB : getNonemptyPredecessors(MBB)) {
        auto& In = Map[&PredMBB->back()].post;
        if (Fwd) {
          Fwd->meetForward(In);
        } else {
          Fwd = In;
        }
      }
      if (Fwd) {
        changed |= Map[&MBB.front()].pre.set_union(*Fwd);
      }

      // Meet backward
      if (!allowDeclassify()) {
        std::optional<Value> Bwd;

        // PTEX-TODO: Allow empty successors.
        for (MachineBasicBlock *SuccMBB : getNonemptySuccessors(MBB)) {
          auto& In = Map[&SuccMBB->front()].pre;
          if (Bwd) {
            Bwd->meetBackward(In);
          } else {
            Bwd = In;
          }
        }
        if (Bwd) {
          changed |= Map[&MBB.back()].post.set_union(*Bwd);
        }
      } 

      // Within same block
      for (auto it1 = MBB.begin(), it2 = std::next(it1); it2 != MBB.end(); ++it1, ++it2) {
        auto& Val1 = Map[&*it1].post;
        auto& Val2 = Map[&*it2].pre;
        changed |= (Val1 != Val2);
        changed |= Val1.set_union(Val2);
        Val2 = Val1;
      }
    }

    // PTEX-TODO: Validate `changed` against backup copy.
  } while (changed);

  return Map;
}

PrivacyTypes runTaintAnalysis(MachineFunction& MF) {
  // PTEX-TODO: Rename.
  return runConstantTimePrivacyAnalysis(MF);
}
  
}
